#!/usr/bin/env node
/*eslint no-console: 0*/
'use strict';


const argparse = require('argparse');
const fs = require('fs');
const path = require('path');
const bolt = require('firebase-bolt');

const packageJson = require('../package.json');

const DEFAULTS = {};
const cmds = [
  {
    name: 'compile',
    description: 'Compile bolt rules',

    options(parser) {
      parser.addArgument(['-o', '--output'], {
        metavar: 'file',
        help: 'output to file.json\n(default: %(defaultValue)s)',
        defaultValue: './rules.json'
      });
      parser.addArgument(['base-rule'], {
        nargs: '*',
        help: 'base rules to merge with the singpath rules'
      });
    },

    cmd(opts) {
      const baseRules = opts['base-rule'].map(loadJsonRules);
      const boltRules = loadBoldRules(path.join(__dirname, '../rules'));

      Promise.all(baseRules.concat(boltRules)).then(
        rulesSet => rulesSet.reduce((merged, rules) => Object.assign(merged, rules), {})
      ).then(
        rules => writeFile(opts.output, JSON.stringify({rules}, null, 2))
      ).catch(err => {
        console.error(err.toString());
      });
    }
  }, {
    name: 'version',
    description: 'Show current version and next upgrades',

    options(parser) {
      parser.addArgument(['-f', '--firebase-id'], {});
    },

    cmd(opts) {
      console.log(opts);
    }
  }, {
    name: 'upgrade',
    description: 'Migrate the firebase db to the next schema version',

    options(parser) {
      parser.addArgument(['-f', '--firebase-id'], {});
    },

    cmd(opts) {
      console.log(opts);
    }
  }
];

if (require.main === module) {
  main();
}

function main() {
  const args = parseArgs();

  args.func(args);
}


function parseArgs(args) {
  const parser = new argparse.ArgumentParser({
    version: packageJson.version,
    addHelp: true,
    description: 'Manage SingPath firebase db rules',
    formatterClass: argparse.RawTextHelpFormatter
  });

  parser.setDefaults(DEFAULTS);

  parser.addArgument(['-d', '--debug' ], {
    action: 'storeTrue',
    help: 'print debug messages'
  });

  parser.addArgument(['-s', '--silent' ], {
    action: 'storeTrue',
    help: 'print only error messages'
  });

  const subparsers = parser.addSubparsers();

  cmds.forEach(sub => {
    const parser =  subparsers.addParser(sub.name, {
      addHelp: true,
      description: sub.description,
      formatterClass: argparse.RawTextHelpFormatter
    });

    sub.options(parser);
    parser.setDefaults({func: sub.cmd});
  });

  return parser.parseArgs(args);
}

function loadJsonRules(path) {
  return readFile(path).then(
    data => JSON.parse(data)
  ).then(
    doc => doc.rules || {}
  );
}

function loadBoldRules(dir) {
  return readBoltFiles(dir).then(
    rules => translateRules(rules)
  ).then(
    doc => doc.rules || {}
  );
}

function readBoltFiles(dir) {
  return scanBoltFiles(dir).then(
    files => files.map(f => path.join(dir, f))
  ).then(
    files => Promise.all(files.map(readFile))
  ).then(
    rules => rules.join('\n')
  );
}

function scanBoltFiles(dir) {
  return new Promise((resolve, reject) => {
    fs.readdir(dir, (err, files) => {
      if (err) {
        reject(err);
      } else {
        resolve(files.filter(
          file => file.endsWith('.bolt')
        ));
      }
    });
  });
}

function translateRules(input) {
  const symbols = bolt.parse(input);
  const gen = new bolt.Generator(symbols);
  return gen.generateRules();
}

function readFile(path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}

function writeFile(path, data) {
  return new Promise((resolve, reject) => {
    fs.writeFile(path, data, err => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}
